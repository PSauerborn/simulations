import json
import subprocess
from datetime import datetime
from enum import Enum
from pathlib import Path
from tempfile import NamedTemporaryFile

import matplotlib.pyplot as plt
import numpy as np
import polars as pl
import structlog
import toml
from matplotlib import style as plt_style
from pydantic import BaseModel, Field, StringConstraints
from typing_extensions import Annotated

plt_style.use("seaborn-v0_8-pastel")

LOGGER = structlog.get_logger()


class SimulationOutputTypeEnum(Enum):
    TRAJECTORY = "trajectory"


class SimulationOutput(BaseModel):
    output_type: Annotated[SimulationOutputTypeEnum, Field(alias="type")]
    filename: Annotated[str, StringConstraints(min_length=1)]


class Simulation(BaseModel):
    simulation_id: Annotated[str, StringConstraints(min_length=1), Field(alias="id")]
    name: Annotated[str, StringConstraints(min_length=1)]
    entrypoint: Annotated[str, StringConstraints(min_length=1)]
    outputs: list[SimulationOutput]
    description: str
    config_path: Annotated[str, StringConstraints(min_length=1)]


class SimulationIndex(BaseModel):
    simulations: list[Simulation]

    def get_simulation(self, simulation_id: str) -> Simulation | None:
        """Get a simulation by its ID.

        Args:
            simulation_id: The unique identifier of the simulation to retrieve.

        Returns:
            The matching Simulation object, or None if not found.
        """

        for simulation in self.simulations:
            if simulation.simulation_id == simulation_id:
                return simulation

        raise ValueError(f"Simulation '{simulation_id}' not found.")


def load_index() -> SimulationIndex:
    """Load the simulation index from the index.json file.

    Reads and parses the index.json file containing simulation metadata.

    Returns:
        A SimulationIndex containing all available simulations.
    """

    with open("index.json", "r") as f:
        index_data = json.load(f)
    return SimulationIndex(**index_data)


def load_simulation_config(path: str) -> dict:
    """Load simulation configuration from a TOML file.

    Reads and parses a TOML configuration file containing simulation
    parameters such as initial conditions, physical constants, and
    output settings.

    Args:
        path: Path to the TOML configuration file.

    Returns:
        A dictionary containing the parsed configuration data.
    """

    with open(path, "r") as f:
        return toml.load(f)


def load_trajectory_data(out: SimulationOutput, output_dir: Path) -> pl.DataFrame:
    """Load trajectory data from a simulation output CSV file.

    Reads the CSV output file generated by the simulation and renames
    columns to x, y, z for 3D trajectory coordinates. The output file
    path is constructed by joining output_dir with the output filename.

    Args:
        out: The simulation output configuration specifying the filename.
        output_dir: Directory containing the simulation output files.

    Returns:
        A DataFrame containing trajectory data with 'x', 'y', 'z' columns.
    """

    path = output_dir / out.filename
    df = pl.read_csv(
        path,
        infer_schema_length=None,
        schema={
            "x1": pl.Float64(),
            "x2": pl.Float64(),
            "x3": pl.Float64(),
        },
    )
    return df


def run_simulation(simulation: Simulation, binary_path: str, output_dir: Path):
    """Run the simulation executable and capture output.

    Loads the simulation's TOML configuration, overrides the output_dir
    setting with the provided output directory, writes the modified config
    to a temporary file, and executes the simulation. Stdout is captured
    and written to simulation.log within the output directory.

    Args:
        simulation: The simulation configuration to run.
        binary_path: Path to the fpm binary.
        output_dir: Directory where output files (data, logs) should be written.
            This path overrides the output_dir in the TOML config.

    Raises:
        subprocess.CalledProcessError: If the simulation fails to execute.
    """

    log_file_path = output_dir / "simulation.log"

    # load TOML configuration path and override config
    config = load_simulation_config(simulation.config_path)
    config["config"]["output_dir"] = str(output_dir)

    with NamedTemporaryFile() as temp:
        with open(temp.name, "w") as f:
            toml.dump(config, f)

        with open(log_file_path, "w") as f:
            subprocess.run(
                [
                    binary_path,
                    "run",
                    "--target",
                    simulation.entrypoint,
                    "--",
                    temp.name,
                ],
                check=True,
                stdout=f,
            )


def plot_trajectory(df: pl.DataFrame, output_dir: Path):
    """Plot a 3D trajectory from simulation output data at multiple viewing angles.

    Creates multiple 3D visualizations of the particle trajectory with start/end
    markers and saves them to PNG files. Generates views from different angles:
    front, side, top, and isometric. The plots use equal aspect ratio scaling
    for accurate spatial representation.

    Args:
        df: DataFrame containing 'x', 'y', 'z' columns with trajectory data.
        output_dir: Directory where the plot images should be saved.
    """

    xs = df["x1"].to_numpy()
    ys = df["x2"].to_numpy()
    zs = df["x3"].to_numpy()

    # Calculate axis limits for consistent scaling across all views
    max_range = (
        np.array([xs.max() - xs.min(), ys.max() - ys.min(), zs.max() - zs.min()]).max()
        / 2.0
    )
    mid_x = (xs.max() + xs.min()) * 0.5
    mid_y = (ys.max() + ys.min()) * 0.5
    mid_z = (zs.max() + zs.min()) * 0.5

    # Define viewing angles: (elevation, azimuth, name)
    views = [
        (30, -60, "isometric"),
        (0, 0, "front_xz"),
        (0, -90, "side_yz"),
        (90, -90, "top_xy"),
    ]

    for elev, azim, view_name in views:
        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection="3d")

        # Plot trajectory and markers for start and end
        ax.plot(xs, ys, zs, label="Trajectory", color="b", lw=2)
        ax.scatter([xs[0]], [ys[0]], [zs[0]], color="g", s=100, label="Start")
        ax.scatter([xs[-1]], [ys[-1]], [zs[-1]], color="r", s=100, label="End")

        ax.set_xlabel("X Position (m)")
        ax.set_ylabel("Y Position (m)")
        ax.set_zlabel("Z Position (m)")
        ax.legend()

        # Apply consistent axis limits
        ax.set_xlim(mid_x - max_range, mid_x + max_range)
        ax.set_ylim(mid_y - max_range, mid_y + max_range)
        ax.set_zlim(mid_z - max_range, mid_z + max_range)

        # Set viewing angle
        ax.view_init(elev=elev, azim=azim)
        ax.set_title(f"Trajectory - {view_name.replace('_', ' ').title()}")

        plt.savefig(
            output_dir / f"trajectory_{view_name}.png", dpi=150, bbox_inches="tight"
        )
        plt.close()


def process_output(out: SimulationOutput, output_dir: Path):
    """Process a simulation output based on its type.

    Handles post-processing of simulation output files. For trajectory
    outputs, this loads the data and generates visualization plots.
    Additional output types can be added via the match statement.

    Args:
        out: The simulation output configuration specifying the output
            type and filename.
        output_dir: Directory containing the output files and where
            generated artifacts (e.g., plots) will be saved.
    """
    LOGGER.info("Processing output.", output_type=out.output_type)

    match out.output_type:
        case SimulationOutputTypeEnum.TRAJECTORY:
            # load trajectory data from output file
            df = load_trajectory_data(out, output_dir)
            # plot trajectory and save to output directory
            plot_trajectory(df, output_dir)
            LOGGER.info("Plots saved.", output_dir=str(output_dir))

        case _:
            raise ValueError(f"Unsupported output type: {out.output_type}")


def main(args):
    """Main entry point for running simulations.

    Loads the simulation index, runs the specified simulation, and generates
    output plots. All output artifacts are saved to a run-specific directory
    with the format: output/id={sim_id}/ts={timestamp}

    Args:
        args: Parsed command-line arguments containing:
            - simulation_id: ID of the simulation to run.
            - fpm_binary_path: Path to fpm binary.
            - output_dir: Base directory for output artifacts.

    Raises:
        ValueError: If the specified simulation_id is not found in the index.
    """

    log = LOGGER.bind(simulation_id=args.simulation_id)

    index = load_index()
    # get simulation by id
    simulation = index.get_simulation(args.simulation_id)

    # current timestamp for run-specific directory
    start_ts = int(datetime.now().timestamp())

    # create run-specific output directory: output/id={sim_id}/ts={ts}
    run_output_dir = (
        Path(args.output_dir) / f"id={args.simulation_id}" / f"ts={start_ts}"
    )
    run_output_dir.mkdir(parents=True, exist_ok=True)

    log.info("Running simulation.", output_dir=str(run_output_dir))
    # run simulation. log files are saved to log_file_path
    run_simulation(simulation, args.fpm_binary_path, run_output_dir)

    end_ts = datetime.now().timestamp()
    log.info(
        "Simulation finished.",
        duration_seconds=round(end_ts - start_ts, 2),
        output_dir=str(run_output_dir),
    )

    # iterate over outputs and process them
    for out in simulation.outputs:
        process_output(out, run_output_dir)


if __name__ == "__main__":

    from argparse import ArgumentParser

    parser = ArgumentParser()

    parser.add_argument("--simulation_id", type=str, required=True)
    parser.add_argument("--fpm-binary-path", type=str, required=False, default="fpm")
    parser.add_argument("--output-dir", type=str, required=False, default="output")

    args = parser.parse_args()

    main(args)
